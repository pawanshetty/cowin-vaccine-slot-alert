import { __awaiter, __generator } from "tslib";
import { sleep } from "./utils/sleep";
import { WaiterState } from "./waiter";
/**
 * Reference: https://awslabs.github.io/smithy/1.0/spec/waiters.html#waiter-retries
 */
var exponentialBackoffWithJitter = function (minDelay, maxDelay, attemptCeiling, attempt) {
    if (attempt > attemptCeiling)
        return maxDelay;
    var delay = minDelay * Math.pow(2, (attempt - 1));
    return randomInRange(minDelay, delay);
};
var randomInRange = function (min, max) { return min + Math.random() * (max - min); };
/**
 * Function that runs polling as part of waiters. This will make one inital attempt and then
 * subsequent attempts with an increasing delay.
 * @param params options passed to the waiter.
 * @param client AWS SDK Client
 * @param input client input
 * @param stateChecker function that checks the acceptor states on each poll.
 */
export var runPolling = function (_a, input, acceptorChecks) {
    var minDelay = _a.minDelay, maxDelay = _a.maxDelay, maxWaitTime = _a.maxWaitTime, abortController = _a.abortController, client = _a.client;
    return __awaiter(void 0, void 0, void 0, function () {
        var state, currentAttempt, waitUntil, attemptCeiling, delay, state_1;
        var _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, acceptorChecks(client, input)];
                case 1:
                    state = (_c.sent()).state;
                    if (state !== WaiterState.RETRY) {
                        return [2 /*return*/, { state: state }];
                    }
                    currentAttempt = 1;
                    waitUntil = Date.now() + maxWaitTime * 1000;
                    attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
                    _c.label = 2;
                case 2:
                    if (!true) return [3 /*break*/, 5];
                    if ((_b = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _b === void 0 ? void 0 : _b.aborted) {
                        return [2 /*return*/, { state: WaiterState.ABORTED }];
                    }
                    delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
                    // Resolve the promise explicitly at timeout or aborted. Otherwise this while loop will keep making API call until
                    // `acceptorCheck` returns non-retry status, even with the Promise.race() outside.
                    if (Date.now() + delay * 1000 > waitUntil) {
                        return [2 /*return*/, { state: WaiterState.TIMEOUT }];
                    }
                    return [4 /*yield*/, sleep(delay)];
                case 3:
                    _c.sent();
                    return [4 /*yield*/, acceptorChecks(client, input)];
                case 4:
                    state_1 = (_c.sent()).state;
                    if (state_1 !== WaiterState.RETRY) {
                        return [2 /*return*/, { state: state_1 }];
                    }
                    currentAttempt += 1;
                    return [3 /*break*/, 2];
                case 5: return [2 /*return*/];
            }
        });
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9sbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3BvbGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0QyxPQUFPLEVBQStCLFdBQVcsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUVwRTs7R0FFRztBQUNILElBQU0sNEJBQTRCLEdBQUcsVUFBQyxRQUFnQixFQUFFLFFBQWdCLEVBQUUsY0FBc0IsRUFBRSxPQUFlO0lBQy9HLElBQUksT0FBTyxHQUFHLGNBQWM7UUFBRSxPQUFPLFFBQVEsQ0FBQztJQUM5QyxJQUFNLEtBQUssR0FBRyxRQUFRLEdBQUcsU0FBQSxDQUFDLEVBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUEsQ0FBQztJQUM1QyxPQUFPLGFBQWEsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDeEMsQ0FBQyxDQUFDO0FBRUYsSUFBTSxhQUFhLEdBQUcsVUFBQyxHQUFXLEVBQUUsR0FBVyxJQUFLLE9BQUEsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsRUFBakMsQ0FBaUMsQ0FBQztBQUV0Rjs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxDQUFDLElBQU0sVUFBVSxHQUFHLFVBQ3hCLEVBQW1GLEVBQ25GLEtBQVksRUFDWixjQUF1RTtRQUZyRSxRQUFRLGNBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxXQUFXLGlCQUFBLEVBQUUsZUFBZSxxQkFBQSxFQUFFLE1BQU0sWUFBQTs7Ozs7O3dCQUl4QyxxQkFBTSxjQUFjLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUFBOztvQkFBN0MsS0FBSyxHQUFLLENBQUEsU0FBbUMsQ0FBQSxNQUF4QztvQkFDYixJQUFJLEtBQUssS0FBSyxXQUFXLENBQUMsS0FBSyxFQUFFO3dCQUMvQixzQkFBTyxFQUFFLEtBQUssT0FBQSxFQUFFLEVBQUM7cUJBQ2xCO29CQUVHLGNBQWMsR0FBRyxDQUFDLENBQUM7b0JBQ2pCLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksQ0FBQztvQkFHNUMsY0FBYyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7eUJBQ2hFLElBQUk7b0JBQ1QsSUFBSSxNQUFBLGVBQWUsYUFBZixlQUFlLHVCQUFmLGVBQWUsQ0FBRSxNQUFNLDBDQUFFLE9BQU8sRUFBRTt3QkFDcEMsc0JBQU8sRUFBRSxLQUFLLEVBQUUsV0FBVyxDQUFDLE9BQU8sRUFBRSxFQUFDO3FCQUN2QztvQkFDSyxLQUFLLEdBQUcsNEJBQTRCLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUUsY0FBYyxDQUFDLENBQUM7b0JBQy9GLGtIQUFrSDtvQkFDbEgsa0ZBQWtGO29CQUNsRixJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxLQUFLLEdBQUcsSUFBSSxHQUFHLFNBQVMsRUFBRTt3QkFDekMsc0JBQU8sRUFBRSxLQUFLLEVBQUUsV0FBVyxDQUFDLE9BQU8sRUFBRSxFQUFDO3FCQUN2QztvQkFDRCxxQkFBTSxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUE7O29CQUFsQixTQUFrQixDQUFDO29CQUNELHFCQUFNLGNBQWMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLEVBQUE7O29CQUE3QyxVQUFVLENBQUEsU0FBbUMsQ0FBQSxNQUF4QztvQkFDYixJQUFJLE9BQUssS0FBSyxXQUFXLENBQUMsS0FBSyxFQUFFO3dCQUMvQixzQkFBTyxFQUFFLEtBQUssU0FBQSxFQUFFLEVBQUM7cUJBQ2xCO29CQUVELGNBQWMsSUFBSSxDQUFDLENBQUM7Ozs7OztDQUV2QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2xlZXAgfSBmcm9tIFwiLi91dGlscy9zbGVlcFwiO1xuaW1wb3J0IHsgV2FpdGVyT3B0aW9ucywgV2FpdGVyUmVzdWx0LCBXYWl0ZXJTdGF0ZSB9IGZyb20gXCIuL3dhaXRlclwiO1xuXG4vKipcbiAqIFJlZmVyZW5jZTogaHR0cHM6Ly9hd3NsYWJzLmdpdGh1Yi5pby9zbWl0aHkvMS4wL3NwZWMvd2FpdGVycy5odG1sI3dhaXRlci1yZXRyaWVzXG4gKi9cbmNvbnN0IGV4cG9uZW50aWFsQmFja29mZldpdGhKaXR0ZXIgPSAobWluRGVsYXk6IG51bWJlciwgbWF4RGVsYXk6IG51bWJlciwgYXR0ZW1wdENlaWxpbmc6IG51bWJlciwgYXR0ZW1wdDogbnVtYmVyKSA9PiB7XG4gIGlmIChhdHRlbXB0ID4gYXR0ZW1wdENlaWxpbmcpIHJldHVybiBtYXhEZWxheTtcbiAgY29uc3QgZGVsYXkgPSBtaW5EZWxheSAqIDIgKiogKGF0dGVtcHQgLSAxKTtcbiAgcmV0dXJuIHJhbmRvbUluUmFuZ2UobWluRGVsYXksIGRlbGF5KTtcbn07XG5cbmNvbnN0IHJhbmRvbUluUmFuZ2UgPSAobWluOiBudW1iZXIsIG1heDogbnVtYmVyKSA9PiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBydW5zIHBvbGxpbmcgYXMgcGFydCBvZiB3YWl0ZXJzLiBUaGlzIHdpbGwgbWFrZSBvbmUgaW5pdGFsIGF0dGVtcHQgYW5kIHRoZW5cbiAqIHN1YnNlcXVlbnQgYXR0ZW1wdHMgd2l0aCBhbiBpbmNyZWFzaW5nIGRlbGF5LlxuICogQHBhcmFtIHBhcmFtcyBvcHRpb25zIHBhc3NlZCB0byB0aGUgd2FpdGVyLlxuICogQHBhcmFtIGNsaWVudCBBV1MgU0RLIENsaWVudFxuICogQHBhcmFtIGlucHV0IGNsaWVudCBpbnB1dFxuICogQHBhcmFtIHN0YXRlQ2hlY2tlciBmdW5jdGlvbiB0aGF0IGNoZWNrcyB0aGUgYWNjZXB0b3Igc3RhdGVzIG9uIGVhY2ggcG9sbC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJ1blBvbGxpbmcgPSBhc3luYyA8Q2xpZW50LCBJbnB1dD4oXG4gIHsgbWluRGVsYXksIG1heERlbGF5LCBtYXhXYWl0VGltZSwgYWJvcnRDb250cm9sbGVyLCBjbGllbnQgfTogV2FpdGVyT3B0aW9uczxDbGllbnQ+LFxuICBpbnB1dDogSW5wdXQsXG4gIGFjY2VwdG9yQ2hlY2tzOiAoY2xpZW50OiBDbGllbnQsIGlucHV0OiBJbnB1dCkgPT4gUHJvbWlzZTxXYWl0ZXJSZXN1bHQ+XG4pOiBQcm9taXNlPFdhaXRlclJlc3VsdD4gPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSBhd2FpdCBhY2NlcHRvckNoZWNrcyhjbGllbnQsIGlucHV0KTtcbiAgaWYgKHN0YXRlICE9PSBXYWl0ZXJTdGF0ZS5SRVRSWSkge1xuICAgIHJldHVybiB7IHN0YXRlIH07XG4gIH1cblxuICBsZXQgY3VycmVudEF0dGVtcHQgPSAxO1xuICBjb25zdCB3YWl0VW50aWwgPSBEYXRlLm5vdygpICsgbWF4V2FpdFRpbWUgKiAxMDAwO1xuICAvLyBUaGUgbWF4IGF0dGVtcHQgbnVtYmVyIHRoYXQgdGhlIGRlcml2ZWQgZGVsYXkgdGltZSB0ZW5kIHRvIGluY3JlYXNlLlxuICAvLyBQcmUtY29tcHV0ZSB0aGlzIG51bWJlciB0byBhdm9pZCBOdW1iZXIgdHlwZSBvdmVyZmxvdy5cbiAgY29uc3QgYXR0ZW1wdENlaWxpbmcgPSBNYXRoLmxvZyhtYXhEZWxheSAvIG1pbkRlbGF5KSAvIE1hdGgubG9nKDIpICsgMTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyPy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiB7IHN0YXRlOiBXYWl0ZXJTdGF0ZS5BQk9SVEVEIH07XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gZXhwb25lbnRpYWxCYWNrb2ZmV2l0aEppdHRlcihtaW5EZWxheSwgbWF4RGVsYXksIGF0dGVtcHRDZWlsaW5nLCBjdXJyZW50QXR0ZW1wdCk7XG4gICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZSBleHBsaWNpdGx5IGF0IHRpbWVvdXQgb3IgYWJvcnRlZC4gT3RoZXJ3aXNlIHRoaXMgd2hpbGUgbG9vcCB3aWxsIGtlZXAgbWFraW5nIEFQSSBjYWxsIHVudGlsXG4gICAgLy8gYGFjY2VwdG9yQ2hlY2tgIHJldHVybnMgbm9uLXJldHJ5IHN0YXR1cywgZXZlbiB3aXRoIHRoZSBQcm9taXNlLnJhY2UoKSBvdXRzaWRlLlxuICAgIGlmIChEYXRlLm5vdygpICsgZGVsYXkgKiAxMDAwID4gd2FpdFVudGlsKSB7XG4gICAgICByZXR1cm4geyBzdGF0ZTogV2FpdGVyU3RhdGUuVElNRU9VVCB9O1xuICAgIH1cbiAgICBhd2FpdCBzbGVlcChkZWxheSk7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gYXdhaXQgYWNjZXB0b3JDaGVja3MoY2xpZW50LCBpbnB1dCk7XG4gICAgaWYgKHN0YXRlICE9PSBXYWl0ZXJTdGF0ZS5SRVRSWSkge1xuICAgICAgcmV0dXJuIHsgc3RhdGUgfTtcbiAgICB9XG5cbiAgICBjdXJyZW50QXR0ZW1wdCArPSAxO1xuICB9XG59O1xuIl19